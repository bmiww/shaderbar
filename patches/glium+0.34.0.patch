diff --git a/Cargo.toml b/Cargo.toml
index 195dc54..82add7c 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,21 +1,7 @@
-# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
-#
-# When uploading crates to the registry Cargo will automatically
-# "normalize" Cargo.toml files for maximal compatibility
-# with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g., crates.io) dependencies.
-#
-# If you are reading this file be aware that the original Cargo.toml
-# will likely look very different (and much more reasonable).
-# See Cargo.toml.orig for the original contents.
-
 [package]
-edition = "2021"
 name = "glium"
 version = "0.34.0"
 authors = ["Pierre Krieger <pierre.krieger1708@gmail.com>"]
-build = "build/main.rs"
-exclude = ["doc"]
 description = """
 Elegant and safe OpenGL wrapper.
 
@@ -30,27 +16,22 @@ Its objectives:
  - Avoid all OpenGL errors beforehand.
  - Produce optimized OpenGL function calls, and allow the user to easily use modern OpenGL techniques.
 """
+keywords = ["opengl", "gamedev"]
+categories = ["api-bindings", "rendering::graphics-api"]
 documentation = "https://docs.rs/glium"
+repository = "https://github.com/glium/glium"
 readme = "README.md"
-keywords = [
-    "opengl",
-    "gamedev",
-]
-categories = [
-    "api-bindings",
-    "rendering::graphics-api",
-]
 license = "Apache-2.0"
-repository = "https://github.com/glium/glium"
-
-[package.metadata.docs.rs]
-all-features = true
-
-[dependencies.backtrace]
-version = "0.3.2"
+build = "build/main.rs"
+exclude = ["doc"]
+edition = "2021"
 
-[dependencies.fnv]
-version = "1.0.5"
+[features]
+default = ["glutin_backend", "simple_window_builder", "glutin/default", "winit/default", "glutin-winit/default"]
+glutin_backend = ["glutin"]
+unstable = [] # used for benchmarks
+vk_interop = [] # used for texture import from Vulkan
+simple_window_builder = ["glutin", "glutin-winit", "winit", "raw-window-handle"] # used in the tutorial
 
 [dependencies.glutin]
 version = "0.31"
@@ -64,78 +45,39 @@ features = []
 optional = true
 default-features = false
 
-[dependencies.lazy_static]
-version = "1.0"
-
-[dependencies.memoffset]
-version = "0.9.0"
-
-[dependencies.raw-window-handle]
-version = "0.5"
+[dependencies.winit]
+version = "0.29"
 features = []
 optional = true
 default-features = false
 
-[dependencies.smallvec]
-version = "1.0"
-
-[dependencies.takeable-option]
+[dependencies.raw-window-handle]
 version = "0.5"
-
-[dependencies.winit]
-version = "0.29"
 features = []
 optional = true
 default-features = false
 
-[dev-dependencies.cgmath]
-version = "0.18"
-
-[dev-dependencies.genmesh]
-version = "0.6"
-
-[dev-dependencies.glutin-winit]
-version = "0.4"
-
-[dev-dependencies.image]
-version = "0.24"
-
-[dev-dependencies.libc]
-version = "0.2.62"
-
-[dev-dependencies.obj]
-version = "0.10"
-features = ["genmesh"]
-
-[dev-dependencies.ouroboros]
-version = "0.18"
+[dependencies]
+memoffset = "0.9.0"
+backtrace = "0.3.2"
+smallvec = "1.0"
+fnv = "1.0.5"
+
+[build-dependencies]
+gl_generator = "0.14"
+
+[dev-dependencies]
+ouroboros = "0.18"
+cgmath = "0.18"
+genmesh = "0.6"
+image = "0.24"
+obj = { version = "0.10", features = ["genmesh"] }
+rand = "0.8"
+libc = "0.2.62"
+winit = "0.29"
+raw-window-handle = "0.5"
+glutin-winit = "0.4"
+takeable-option = "0.5"
 
-[dev-dependencies.rand]
-version = "0.8"
-
-[dev-dependencies.raw-window-handle]
-version = "0.5"
-
-[dev-dependencies.winit]
-version = "0.29"
-
-[build-dependencies.gl_generator]
-version = "0.14"
-
-[features]
-default = [
-    "glutin_backend",
-    "simple_window_builder",
-    "glutin/default",
-    "winit/default",
-    "glutin-winit/default",
-]
-glutin_backend = ["glutin"]
-simple_window_builder = [
-    "glutin",
-    "glutin-winit",
-    "winit",
-    "raw-window-handle",
-]
-unstable = []
-vk_interop = []
+[package.metadata.docs.rs]
+all-features = true
diff --git a/book/tuto-01-getting-started.md b/book/tuto-01-getting-started.md
index 07863b6..d01de87 100644
--- a/book/tuto-01-getting-started.md
+++ b/book/tuto-01-getting-started.md
@@ -40,7 +40,7 @@ This will open a new window, register it with the given event_loop and create a
 
 ```rust
 fn main() {
-    let event_loop = winit::event_loop::EventLoopBuilder::new().build();
+    let event_loop = winit::event_loop::EventLoopBuilder::new().build().expect("event loop building");
     let (_window, display) = glium::backend::glutin::SimpleWindowBuilder::new().build(&event_loop);
 }
 ```
@@ -48,16 +48,14 @@ fn main() {
 If you try to run this example with `cargo run` you'll encounter a problem: as soon as the window has been created, our main function exits and the window is closed. To prevent this, we need to wait until we receive a `CloseRequested` event. We do this by calling `event_loop.run`:
 
 ```rust
-event_loop.run(move |ev, _, control_flow| {
-    match ev {
+let _ = event_loop.run(move |event, window_target| {
+    match event {
         winit::event::Event::WindowEvent { event, .. } => match event {
-            winit::event::WindowEvent::CloseRequested => {
-                *control_flow =  winit::event_loop::ControlFlow::Exit;
-            },
-            _ => (),
+	    winit::event::WindowEvent::CloseRequested => window_target.exit(),
+	    _ => (),
         },
         _ => (),
-    }
+    };
 });
 ```
 
@@ -102,18 +100,18 @@ Here is our full program:
 use glium::Surface;
 
 fn main() {
-    let event_loop = winit::event_loop::EventLoopBuilder::new().build();
+    let event_loop = winit::event_loop::EventLoopBuilder::new().build().expect("event loop building");
     let (_window, display) = glium::backend::glutin::SimpleWindowBuilder::new().build(&event_loop);
 
     let mut frame = display.draw();
     frame.clear_color(0.0, 0.0, 1.0, 1.0);
     frame.finish().unwrap();
 
-    event_loop.run(move |event, _, control_flow| {
+    let _ = event_loop.run(move |event, window_target| {
         match event {
             winit::event::Event::WindowEvent { event, .. } => match event {
-                winit::event::WindowEvent::CloseRequested => control_flow.set_exit(),
-                _ => (),
+	        winit::event::WindowEvent::CloseRequested => window_target.exit(),
+	        _ => (),
             },
             _ => (),
         };
diff --git a/book/tuto-02-triangle.md b/book/tuto-02-triangle.md
index 197ece6..2864a57 100644
--- a/book/tuto-02-triangle.md
+++ b/book/tuto-02-triangle.md
@@ -78,7 +78,7 @@ The tricky part is that *we* need to write the vertex and fragment shaders. To d
 
 ```rust
 let vertex_shader_src = r#"
-    ##version 140
+    #version 140
 
     in vec2 position;
 
@@ -98,7 +98,7 @@ The second shader is called the fragment shader (sometimes also named *pixel sha
 
 ```rust
 let fragment_shader_src = r#"
-    ##version 140
+    #version 140
 
     out vec4 color;
 
diff --git a/book/tuto-03-animated-triangle.md b/book/tuto-03-animated-triangle.md
index 383f221..c54b549 100644
--- a/book/tuto-03-animated-triangle.md
+++ b/book/tuto-03-animated-triangle.md
@@ -5,15 +5,15 @@ Now that we have a triangle, we are going to animate it. Remember that OpenGL is
 So far we have only ever rendered a single frame and then waited for the program to exit. For an animation to show we need to change the way we draw our triangle. Instead of drawing a frame and then waiting in our event_loop for the window to close, we first draw our triangle when requested by the operating system:
 
 ```rust
-event_loop.run(move |event, _, control_flow| {
+let _ = event_loop.run(move |event, window_target| {
     match event {
         winit::event::Event::WindowEvent { event, .. } => match event {
-            winit::event::WindowEvent::CloseRequested => control_flow.set_exit(),
+            winit::event::WindowEvent::CloseRequested => window_target.exit(),
+            winit::event::WindowEvent::RedrawRequested => {
+                // Move the draw code here!
+            },
             _ => (),
         },
-        winit::event::Event::RedrawRequested(_) => {
-            // Move the draw code here!
-        },
         _ => (),
     };
 });
@@ -22,18 +22,18 @@ event_loop.run(move |event, _, control_flow| {
 What exactly triggers this event is platform specific, but in order to draw our triangle over and over again we can request a redraw ourselves once we've finished rendering, to do that we'll respond to yet another event:
 
 ```rust
-event_loop.run(move |event, _, control_flow| {
+let _ = event_loop.run(move |event, window_target| {
     match event {
         winit::event::Event::WindowEvent { event, .. } => match event {
-            winit::event::WindowEvent::CloseRequested => control_flow.set_exit(),
+            winit::event::WindowEvent::CloseRequested => window_target.exit(),
+            winit::event::WindowEvent::RedrawRequested => {
+                // Move the draw code here!
+            },
             _ => (),
         },
-        winit::event::Event::RedrawEventsCleared => {
+        winit::event::Event::AboutToWait => {
             window.request_redraw();
         },
-        winit::event::Event::RedrawRequested(_) => {
-            // Move the draw code here!
-        },
         _ => (),
     };
 });
@@ -45,21 +45,21 @@ While we are working on our event_loop there is one more event that we should ha
 
 ```rust
 let mut t: f32 = 0.0;
-event_loop.run(move |event, _, control_flow| {
+let _ = event_loop.run(move |event, window_target| {
     match event {
         winit::event::Event::WindowEvent { event, .. } => match event {
-            winit::event::WindowEvent::CloseRequested => control_flow.set_exit(),
+            winit::event::WindowEvent::CloseRequested => window_target.exit(),
             winit::event::WindowEvent::Resized(window_size) => {
                 display.resize(window_size.into());
             },
+            winit::event::WindowEvent::RedrawRequested => {
+                // Move the draw code here!
+            },
             _ => (),
         },
-        winit::event::Event::RedrawEventsCleared => {
+        winit::event::Event::AboutToWait => {
             window.request_redraw();
         },
-        winit::event::Event::RedrawRequested(_) => {
-            // Move the draw code here!
-        },
         _ => (),
     };
 });
@@ -73,37 +73,37 @@ Our first approach will be to create a variable named `t` which represents the s
 
 ```rust
 let mut t: f32 = 0.0;
-event_loop.run(move |event, _, control_flow| {
+let _ = event_loop.run(move |event, window_target| {
     match event {
         winit::event::Event::WindowEvent { event, .. } => match event {
-            winit::event::WindowEvent::CloseRequested => control_flow.set_exit(),
+            winit::event::WindowEvent::CloseRequested => window_target.exit(),
             winit::event::WindowEvent::Resized(window_size) => {
                 display.resize(window_size.into());
             },
+            winit::event::WindowEvent::RedrawRequested => {
+                // We update `t`
+                t += 0.02;
+                // We use the sine of t as an offset, this way we get a nice smooth animation
+                let x_off = t.sin() * 0.5;
+
+                let shape = vec![
+                    Vertex { position: [-0.5 + x_off, -0.5] },
+                    Vertex { position: [ 0.0 + x_off,  0.5] },
+                    Vertex { position: [ 0.5 + x_off, -0.25] }
+                ];
+                let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();
+
+                let mut target = display.draw();
+                target.clear_color(0.0, 0.0, 1.0, 1.0);
+                target.draw(&vertex_buffer, &indices, &program, &glium::uniforms::EmptyUniforms,
+                        &Default::default()).unwrap();
+                target.finish().unwrap();
+            },
             _ => (),
         },
-        winit::event::Event::RedrawEventsCleared => {
+        winit::event::Event::AboutToWait => {
             window.request_redraw();
         },
-        winit::event::Event::RedrawRequested(_) => {
-            // We update `t`
-            t += 0.02;
-            // We use the sine of t as an offset, this way we get a nice smooth animation
-            let x_off = t.sin() * 0.5;
-
-            let shape = vec![
-                Vertex { position: [-0.5 + x_off, -0.5] },
-                Vertex { position: [ 0.0 + x_off,  0.5] },
-                Vertex { position: [ 0.5 + x_off, -0.25] }
-            ];
-            let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();
-
-            let mut target = display.draw();
-            target.clear_color(0.0, 0.0, 1.0, 1.0);
-            target.draw(&vertex_buffer, &indices, &program, &glium::uniforms::EmptyUniforms,
-                    &Default::default()).unwrap();
-            target.finish().unwrap();
-        },
         _ => (),
     };
 });
@@ -125,30 +125,30 @@ Let's remove the two `let`'s that redefine our shape and vertex_buffer from our
 
 ```rust
 let mut t: f32 = 0.0;
-event_loop.run(move |event, _, control_flow| {
+let _ = event_loop.run(move |event, window_target| {
     match event {
         winit::event::Event::WindowEvent { event, .. } => match event {
-            winit::event::WindowEvent::CloseRequested => control_flow.set_exit(),
+            winit::event::WindowEvent::CloseRequested => window_target.exit(),
             winit::event::WindowEvent::Resized(window_size) => {
                 display.resize(window_size.into());
             },
+	    winit::event::WindowEvent::RedrawRequested => {
+	        // We update `t`
+	        t += 0.02;
+                // We use the sine of t as an offset, this way we get a nice smooth animation
+	        let x_off = t.sin() * 0.5;
+
+	        let mut target = display.draw();
+	        target.clear_color(0.0, 0.0, 1.0, 1.0);
+	        target.draw(&vertex_buffer, &indices, &program, &glium::uniforms::EmptyUniforms,
+			    &Default::default()).unwrap();
+	        target.finish().unwrap();
+	    },
             _ => (),
         },
-        winit::event::Event::RedrawEventsCleared => {
+        winit::event::Event::AboutToWait => {
             window.request_redraw();
         },
-        winit::event::Event::RedrawRequested(_) => {
-            // We update `t`
-            t += 0.02;
-            // We use the sine of t as an offset, this way we get a nice smooth animation
-            let x = t.sin() * 0.5;
-
-            let mut target = display.draw();
-            target.clear_color(0.0, 0.0, 1.0, 1.0);
-            target.draw(&vertex_buffer, &indices, &program, &glium::uniforms::EmptyUniforms,
-                    &Default::default()).unwrap();
-            target.finish().unwrap();
-        },
         _ => (),
     };
 });
@@ -175,7 +175,7 @@ let vertex_shader_src = r#"
 You may notice that this is exactly the operation that we've been doing above, except that this time it is done on the GPU side. We have added a variable `t` in our shader, which is declared as a **uniform**. A uniform is a global variable whose value is set when we draw by passing its value to the `draw` function. The easiest way to do so is to use the `uniform!` macro:
 
 ```rust
-target.draw(&vertex_buffer, &indices, &program, &uniform! { x: x },
+target.draw(&vertex_buffer, &indices, &program, &uniform! { x: x_off },
             &Default::default()).unwrap();
 ```
 
diff --git a/book/tuto-04-matrices.md b/book/tuto-04-matrices.md
index e7d54a1..7527485 100644
--- a/book/tuto-04-matrices.md
+++ b/book/tuto-04-matrices.md
@@ -17,7 +17,7 @@ Let's get back to our moving triangle. We are going to change the vertex shader
 
 ```rust
 let vertex_shader_src = r#"
-    ##version 140
+    #version 140
 
     in vec2 position;
 
diff --git a/book/tuto-06-texture.md b/book/tuto-06-texture.md
index 4d21467..30cf8fd 100644
--- a/book/tuto-06-texture.md
+++ b/book/tuto-06-texture.md
@@ -22,7 +22,7 @@ let image = glium::texture::RawImage2d::from_raw_rgba_reversed(&image.into_raw()
 And in order to upload the image as a texture, it's as simple as:
 
 ```rust
-let texture = glium::texture::SrgbTexture2d::new(&display, image).unwrap();
+let texture = glium::texture::Texture2d::new(&display, image).unwrap();
 ```
 
 # Using the texture
@@ -97,7 +97,7 @@ let uniforms = uniform! {
         [1.0, 0.0, 0.0, 0.0],
         [0.0, 1.0, 0.0, 0.0],
         [0.0, 0.0, 1.0, 0.0],
-        [ t , 0.0, 0.0, 1.0f32],
+        [ x , 0.0, 0.0, 1.0f32],
     ],
     tex: &texture,
 };
diff --git a/book/tuto-14-wall.md b/book/tuto-14-wall.md
index 6d7ac0a..7c1f505 100644
--- a/book/tuto-14-wall.md
+++ b/book/tuto-14-wall.md
@@ -54,7 +54,7 @@ let image = image::load(Cursor::new(&include_bytes!("../book/tuto-14-diffuse.jpg
                         image::JPEG).unwrap().to_rgba8();
 let image_dimensions = image.dimensions();
 let image = glium::texture::RawImage2d::from_raw_rgba_reversed(&image.into_raw(), image_dimensions);
-let diffuse_texture = glium::texture::SrgbTexture2d::new(&display, image).unwrap();
+let diffuse_texture = glium::texture::Texture2d::new(&display, image).unwrap();
 ```
 
 Adding the texture coordinates is also very easy:
diff --git a/examples/manual-creation.rs b/examples/manual-creation.rs
index 44f9814..75c3146 100644
--- a/examples/manual-creation.rs
+++ b/examples/manual-creation.rs
@@ -17,7 +17,6 @@ There are three concepts in play:
 
 */
 
-use glium::{self};
 use winit::event_loop::EventLoopBuilder;
 use winit::window::WindowBuilder;
 use glium::Surface;
diff --git a/examples/screenshot-asynchronous.rs b/examples/screenshot-asynchronous.rs
index d54d74a..64f6c86 100644
--- a/examples/screenshot-asynchronous.rs
+++ b/examples/screenshot-asynchronous.rs
@@ -12,7 +12,6 @@ use winit::keyboard::{PhysicalKey, KeyCode};
 mod screenshot {
     use glium::Surface;
     use std::collections::VecDeque;
-    use std::vec::Vec;
     use std::borrow::Cow;
 
     // Container that holds image data as vector of (u8, u8, u8, u8).
diff --git a/examples/support/mod.rs b/examples/support/mod.rs
index 809603f..1a3aed3 100644
--- a/examples/support/mod.rs
+++ b/examples/support/mod.rs
@@ -1,6 +1,6 @@
 #![allow(dead_code)]
 use std::num::NonZeroU32;
-use glium::{self, Display};
+use glium::Display;
 use glutin::prelude::*;
 use glutin::display::GetGlDisplay;
 use glutin::surface::WindowSurface;
diff --git a/examples/tutorial-14.rs b/examples/tutorial-14.rs
index a0390aa..05dcb09 100644
--- a/examples/tutorial-14.rs
+++ b/examples/tutorial-14.rs
@@ -31,7 +31,7 @@ fn main() {
                             image::ImageFormat::Jpeg).unwrap().to_rgba8();
     let image_dimensions = image.dimensions();
     let image = glium::texture::RawImage2d::from_raw_rgba_reversed(&image.into_raw(), image_dimensions);
-    let diffuse_texture = glium::texture::SrgbTexture2d::new(&display, image).unwrap();
+    let diffuse_texture = glium::texture::Texture2d::new(&display, image).unwrap();
 
     let image = image::load(std::io::Cursor::new(&include_bytes!("../book/resources/tuto-14-normal.png")),
                             image::ImageFormat::Png).unwrap().to_rgba8();
diff --git a/src/backend/glutin/mod.rs b/src/backend/glutin/mod.rs
index 7195c89..011f601 100644
--- a/src/backend/glutin/mod.rs
+++ b/src/backend/glutin/mod.rs
@@ -10,18 +10,18 @@ Only available if the 'glutin' feature is enabled.
 */
 pub use glutin;
 use glutin::surface::Surface;
-use takeable_option::Takeable;
 
-use crate::SwapBuffersError;
 use crate::backend;
 use crate::backend::Backend;
 use crate::backend::Context;
 use crate::context;
 use crate::debug;
-use crate::glutin::prelude::*;
 use crate::glutin::context::PossiblyCurrentContext;
 use crate::glutin::display::GetGlDisplay;
-use crate::glutin::surface::{SurfaceTypeTrait, ResizeableSurface};
+use crate::glutin::prelude::*;
+use crate::glutin::surface::{ResizeableSurface, SurfaceTypeTrait};
+use crate::SwapBuffersError;
+use crate::{Frame, IncompatibleOpenGl};
 use std::cell::RefCell;
 use std::error::Error;
 use std::ffi::CString;
@@ -30,7 +30,6 @@ use std::num::NonZeroU32;
 use std::ops::Deref;
 use std::os::raw::c_void;
 use std::rc::Rc;
-use crate::{Frame, IncompatibleOpenGl};
 
 /// Wraps a glutin context together with the corresponding Surface.
 /// This is necessary so that we can swap buffers and determine the framebuffer size within glium.
@@ -47,7 +46,10 @@ impl<T: SurfaceTypeTrait + ResizeableSurface> ContextSurfacePair<T> {
     #[inline]
     /// Return the stored framebuffer dimensions
     pub fn get_framebuffer_dimensions(&self) -> (u32, u32) {
-        (self.surface.width().unwrap(), self.surface.height().unwrap())
+        (
+            self.surface.width().unwrap(),
+            self.surface.height().unwrap(),
+        )
     }
 
     #[inline]
@@ -58,7 +60,7 @@ impl<T: SurfaceTypeTrait + ResizeableSurface> ContextSurfacePair<T> {
 
     #[inline]
     /// Resize the associated surface
-    pub fn resize(&self, new_size:(u32, u32)) {
+    pub fn resize(&self, new_size: (u32, u32)) {
         // Make sure that no dimension is zero, which happens when minimizing on Windows for example.
         let width = NonZeroU32::new(new_size.0).unwrap_or(NonZeroU32::new(1).unwrap());
         let height = NonZeroU32::new(new_size.1).unwrap_or(NonZeroU32::new(1).unwrap());
@@ -84,12 +86,14 @@ pub struct Display<T: SurfaceTypeTrait + ResizeableSurface + 'static> {
     // contains everything related to the current glium context and its state
     context: Rc<context::Context>,
     // The glutin Surface alongside its associated glutin Context.
-    gl_context: Rc<RefCell<Takeable<ContextSurfacePair<T>>>>,
+    gl_context: Rc<RefCell<Option<ContextSurfacePair<T>>>>,
 }
 
 /// An implementation of the `Backend` trait for glutin.
 #[derive(Clone)]
-pub struct GlutinBackend<T: SurfaceTypeTrait + ResizeableSurface>(Rc<RefCell<Takeable<ContextSurfacePair<T>>>>);
+pub struct GlutinBackend<T: SurfaceTypeTrait + ResizeableSurface>(
+    Rc<RefCell<Option<ContextSurfacePair<T>>>>,
+);
 
 /// Error that can happen while creating a glium display.
 #[derive(Debug)]
@@ -165,7 +169,7 @@ impl<T: SurfaceTypeTrait + ResizeableSurface> Display<T> {
         checked: bool,
     ) -> Result<Self, IncompatibleOpenGl> {
         let context_surface_pair = ContextSurfacePair::new(context, surface);
-        let gl_window = Rc::new(RefCell::new(Takeable::new(context_surface_pair)));
+        let gl_window = Rc::new(RefCell::new(Some(context_surface_pair)));
         let glutin_backend = GlutinBackend(gl_window.clone());
         let context = unsafe { context::Context::new(glutin_backend, checked, debug) }?;
         Ok(Display {
@@ -176,8 +180,8 @@ impl<T: SurfaceTypeTrait + ResizeableSurface> Display<T> {
 
     /// Resize the underlying surface.
     #[inline]
-    pub fn resize(&self, new_size:(u32, u32)) {
-        self.gl_context.borrow().resize(new_size)
+    pub fn resize(&self, new_size: (u32, u32)) {
+        self.gl_context.borrow().as_ref().unwrap().resize(new_size)
     }
 
     /// Start drawing on the backbuffer.
@@ -242,7 +246,7 @@ impl<T: SurfaceTypeTrait + ResizeableSurface> backend::Facade for Display<T> {
 }
 
 impl<T: SurfaceTypeTrait + ResizeableSurface> Deref for GlutinBackend<T> {
-    type Target = Rc<RefCell<Takeable<ContextSurfacePair<T>>>>;
+    type Target = Rc<RefCell<Option<ContextSurfacePair<T>>>>;
     #[inline]
     fn deref(&self) -> &Self::Target {
         &self.0
@@ -252,7 +256,7 @@ impl<T: SurfaceTypeTrait + ResizeableSurface> Deref for GlutinBackend<T> {
 unsafe impl<T: SurfaceTypeTrait + ResizeableSurface> Backend for GlutinBackend<T> {
     #[inline]
     fn swap_buffers(&self) -> Result<(), SwapBuffersError> {
-        match self.borrow().swap_buffers() {
+        match self.borrow().as_ref().unwrap().swap_buffers() {
             Ok(()) => Ok(()),
             _ => Err(SwapBuffersError::ContextLost),
         }
@@ -261,35 +265,47 @@ unsafe impl<T: SurfaceTypeTrait + ResizeableSurface> Backend for GlutinBackend<T
     #[inline]
     unsafe fn get_proc_address(&self, symbol: &str) -> *const c_void {
         let symbol = CString::new(symbol).unwrap();
-        self.borrow().display().get_proc_address(&symbol) as *const _
+        self.borrow()
+            .as_ref()
+            .unwrap()
+            .display()
+            .get_proc_address(&symbol) as *const _
     }
 
     #[inline]
     fn get_framebuffer_dimensions(&self) -> (u32, u32) {
-        self.0.borrow().get_framebuffer_dimensions()
+        self.0
+            .borrow()
+            .as_ref()
+            .unwrap()
+            .get_framebuffer_dimensions()
     }
 
     #[inline]
-    fn resize(&self, new_size:(u32, u32)) {
-        self.borrow().resize(new_size)
+    fn resize(&self, new_size: (u32, u32)) {
+        self.borrow().as_ref().unwrap().resize(new_size)
     }
 
     #[inline]
     fn is_current(&self) -> bool {
-        self.borrow().is_current()
+        self.borrow().as_ref().unwrap().is_current()
     }
 
     #[inline]
     unsafe fn make_current(&self) {
         let pair = self.borrow();
-        pair.context.make_current(&pair.surface).unwrap();
+        pair.as_ref()
+            .unwrap()
+            .context
+            .make_current(&pair.as_ref().unwrap().surface)
+            .unwrap();
     }
 }
 
 #[cfg(feature = "simple_window_builder")]
 /// Builder to simplify glium/glutin context creation.
 pub struct SimpleWindowBuilder {
-    builder: winit::window::WindowBuilder
+    builder: winit::window::WindowBuilder,
 }
 
 #[cfg(feature = "simple_window_builder")]
@@ -299,14 +315,16 @@ impl SimpleWindowBuilder {
         Self {
             builder: winit::window::WindowBuilder::new()
                 .with_title("Simple Glium Window")
-                .with_inner_size(winit::dpi::PhysicalSize::new(800, 480))
+                .with_inner_size(winit::dpi::PhysicalSize::new(800, 480)),
         }
     }
 
     /// Requests the window to be of a certain size.
     /// If this is not set, the builder defaults to 800x480.
     pub fn with_inner_size(mut self, width: u32, height: u32) -> Self {
-        self.builder = self.builder.with_inner_size(winit::dpi::PhysicalSize::new(width, height));
+        self.builder = self
+            .builder
+            .with_inner_size(winit::dpi::PhysicalSize::new(width, height));
         self
     }
 
@@ -330,12 +348,19 @@ impl SimpleWindowBuilder {
 
     /// Create a new [`Window`](winit::window::Window) and [`Display`]
     /// with the specified parameters.
-    pub fn build<T>(self, event_loop: &winit::event_loop::EventLoop<T>) -> (winit::window::Window, Display<glutin::surface::WindowSurface>) {
+    pub fn build<T>(
+        self,
+        event_loop: &winit::event_loop::EventLoop<T>,
+    ) -> (
+        winit::window::Window,
+        Display<glutin::surface::WindowSurface>,
+    ) {
         use glutin::prelude::*;
         use raw_window_handle::HasRawWindowHandle;
 
         // First we start by opening a new Window
-        let display_builder = glutin_winit::DisplayBuilder::new().with_window_builder(Some(self.builder));
+        let display_builder =
+            glutin_winit::DisplayBuilder::new().with_window_builder(Some(self.builder));
         let config_template_builder = glutin::config::ConfigTemplateBuilder::new();
         let (window, gl_config) = display_builder
             .build(&event_loop, config_template_builder, |mut configs| {
@@ -347,18 +372,32 @@ impl SimpleWindowBuilder {
 
         // Now we get the window size to use as the initial size of the Surface
         let (width, height): (u32, u32) = window.inner_size().into();
-        let attrs = glutin::surface::SurfaceAttributesBuilder::<glutin::surface::WindowSurface>::new().build(
-            window.raw_window_handle(),
-            NonZeroU32::new(width).unwrap(),
-            NonZeroU32::new(height).unwrap(),
-        );
+        let attrs =
+            glutin::surface::SurfaceAttributesBuilder::<glutin::surface::WindowSurface>::new()
+                .build(
+                    window.raw_window_handle(),
+                    NonZeroU32::new(width).unwrap(),
+                    NonZeroU32::new(height).unwrap(),
+                );
 
         // Finally we can create a Surface, use it to make a PossiblyCurrentContext and create the glium Display
-        let surface = unsafe { gl_config.display().create_window_surface(&gl_config, &attrs).unwrap() };
-        let context_attributes = glutin::context::ContextAttributesBuilder::new().build(Some(window.raw_window_handle()));
+        let surface = unsafe {
+            gl_config
+                .display()
+                .create_window_surface(&gl_config, &attrs)
+                .unwrap()
+        };
+        let context_attributes = glutin::context::ContextAttributesBuilder::new()
+            .build(Some(window.raw_window_handle()));
         let current_context = Some(unsafe {
-            gl_config.display().create_context(&gl_config, &context_attributes).expect("failed to create context")
-        }).unwrap().make_current(&surface).unwrap();
+            gl_config
+                .display()
+                .create_context(&gl_config, &context_attributes)
+                .expect("failed to create context")
+        })
+        .unwrap()
+        .make_current(&surface)
+        .unwrap();
         let display = Display::from_context_surface(current_context, surface).unwrap();
 
         (window, display)
diff --git a/src/context/extensions.rs b/src/context/extensions.rs
index 917b546..7a4a0e2 100644
--- a/src/context/extensions.rs
+++ b/src/context/extensions.rs
@@ -9,6 +9,7 @@ macro_rules! extensions {
         #[derive(Debug, Clone, Copy)]
         pub struct ExtensionsList {
             $(
+                #[allow(missing_docs)]
                 pub $field: bool,
             )+
         }
diff --git a/src/context/mod.rs b/src/context/mod.rs
index 13ff3dd..8b19026 100644
--- a/src/context/mod.rs
+++ b/src/context/mod.rs
@@ -2,28 +2,28 @@
 
 use crate::gl;
 
-use std::collections::HashMap;
-use std::mem;
-use std::ptr;
-use std::str;
 use std::borrow::Cow;
 use std::cell::{Cell, RefCell, RefMut};
-use std::marker::PhantomData;
+use std::collections::HashMap;
 use std::ffi::CStr;
-use std::rc::Rc;
-use std::os::raw;
 use std::hash::BuildHasherDefault;
+use std::marker::PhantomData;
+use std::mem;
+use std::os::raw;
+use std::ptr;
+use std::rc::Rc;
+use std::str;
 
 use fnv::FnvHasher;
 
-use crate::IncompatibleOpenGl;
-use crate::SwapBuffersError;
-use crate::CapabilitiesSource;
-use crate::ContextExt;
 use crate::backend::Backend;
 use crate::version;
 use crate::version::Api;
 use crate::version::Version;
+use crate::CapabilitiesSource;
+use crate::ContextExt;
+use crate::IncompatibleOpenGl;
+use crate::SwapBuffersError;
 
 use crate::debug;
 use crate::fbo;
@@ -33,7 +33,7 @@ use crate::texture;
 use crate::uniforms;
 use crate::vertex_array_object;
 
-pub use self::capabilities::{ReleaseBehavior, Capabilities, Profile};
+pub use self::capabilities::{Capabilities, Profile, ReleaseBehavior};
 pub use self::extensions::ExtensionsList;
 pub use self::state::GlState;
 pub use self::uuid::UuidError;
@@ -88,7 +88,13 @@ pub struct Context {
     vertex_array_objects: vertex_array_object::VertexAttributesSystem,
 
     /// We maintain a list of samplers for each possible behavior.
-    samplers: RefCell<HashMap<uniforms::SamplerBehavior, sampler_object::SamplerObject, BuildHasherDefault<FnvHasher>>>,
+    samplers: RefCell<
+        HashMap<
+            uniforms::SamplerBehavior,
+            sampler_object::SamplerObject,
+            BuildHasherDefault<FnvHasher>,
+        >,
+    >,
 
     /// List of texture handles that are resident. We need to call `MakeTextureHandleResidentARB`
     /// when rebuilding the context.
@@ -128,7 +134,14 @@ pub struct CommandContext<'a> {
     pub framebuffer_objects: &'a fbo::FramebuffersContainer,
 
     /// The list of samplers.
-    pub samplers: RefMut<'a, HashMap<uniforms::SamplerBehavior, sampler_object::SamplerObject, BuildHasherDefault<FnvHasher>>>,
+    pub samplers: RefMut<
+        'a,
+        HashMap<
+            uniforms::SamplerBehavior,
+            sampler_object::SamplerObject,
+            BuildHasherDefault<FnvHasher>,
+        >,
+    >,
 
     /// List of texture handles that need to be made resident.
     pub resident_texture_handles: RefMut<'a, Vec<gl::types::GLuint64>>,
@@ -160,7 +173,8 @@ impl Context {
         check_current_context: bool,
         callback_behavior: DebugCallbackBehavior,
     ) -> Result<Rc<Context>, IncompatibleOpenGl>
-        where B: Backend + 'static
+    where
+        B: Backend + 'static,
     {
         backend.make_current();
 
@@ -186,15 +200,18 @@ impl Context {
 
         let (debug_callback, synchronous) = match callback_behavior {
             DebugCallbackBehavior::Ignore => (None, false),
-            DebugCallbackBehavior::DebugMessageOnError => {
-                (Some(Box::new(default_debug_callback) as debug::DebugCallback), true)
-            },
-            DebugCallbackBehavior::PrintAll => {
-                (Some(Box::new(printall_debug_callback) as debug::DebugCallback), false)
-            },
-            DebugCallbackBehavior::Custom { callback, synchronous } => {
-                (Some(callback), synchronous)
-            },
+            DebugCallbackBehavior::DebugMessageOnError => (
+                Some(Box::new(default_debug_callback) as debug::DebugCallback),
+                true,
+            ),
+            DebugCallbackBehavior::PrintAll => (
+                Some(Box::new(printall_debug_callback) as debug::DebugCallback),
+                false,
+            ),
+            DebugCallbackBehavior::Custom {
+                callback,
+                synchronous,
+            } => (Some(callback), synchronous),
         };
 
         let context = Rc::new(Context {
@@ -222,12 +239,14 @@ impl Context {
         {
             let mut ctxt = context.make_current();
             if crate::get_gl_error(&mut ctxt).is_some() {
-                eprintln!("glium has triggered an OpenGL error during initialization. Please report \
-                           this error: https://github.com/glium/glium/issues");
+                eprintln!(
+                    "glium has triggered an OpenGL error during initialization. Please report \
+                           this error: https://github.com/glium/glium/issues"
+                );
             }
             /*assert!(::get_gl_error(&mut ctxt).is_none(),
-                    "glium has triggered an OpenGL error during initialization. Please report \
-                     this error: https://github.com/glium/glium/issues");*/
+            "glium has triggered an OpenGL error during initialization. Please report \
+             this error: https://github.com/glium/glium/issues");*/
             if ctxt.version >= &Version(Api::Gl, 3, 2) && ctxt.extensions.gl_arb_seamless_cube_map {
                 ctxt.gl.Enable(gl::TEXTURE_CUBE_MAP_SEAMLESS);
             }
@@ -246,7 +265,8 @@ impl Context {
     ///
     /// The new context **must** have lists shared with the old one.
     pub unsafe fn rebuild<B>(&self, new_backend: B) -> Result<(), IncompatibleOpenGl>
-        where B: Backend + 'static
+    where
+        B: Backend + 'static,
     {
         // framebuffer objects and vertex array objects aren't shared,
         // so we have to destroy them
@@ -290,18 +310,23 @@ impl Context {
         if self.state.borrow().draw_framebuffer != 0 || self.state.borrow().read_framebuffer != 0 {
             let mut ctxt = self.make_current();
 
-            if ctxt.version >= &Version(Api::Gl, 3, 0) ||
-               ctxt.extensions.gl_arb_framebuffer_object
+            if ctxt.version >= &Version(Api::Gl, 3, 0) || ctxt.extensions.gl_arb_framebuffer_object
             {
-                unsafe { ctxt.gl.BindFramebuffer(gl::FRAMEBUFFER, 0); }
+                unsafe {
+                    ctxt.gl.BindFramebuffer(gl::FRAMEBUFFER, 0);
+                }
                 ctxt.state.draw_framebuffer = 0;
                 ctxt.state.read_framebuffer = 0;
             } else if ctxt.version >= &Version(Api::GlEs, 2, 0) {
-                unsafe { ctxt.gl.BindFramebuffer(gl::FRAMEBUFFER, 0); }
+                unsafe {
+                    ctxt.gl.BindFramebuffer(gl::FRAMEBUFFER, 0);
+                }
                 ctxt.state.draw_framebuffer = 0;
                 ctxt.state.read_framebuffer = 0;
             } else if ctxt.extensions.gl_ext_framebuffer_object {
-                unsafe { ctxt.gl.BindFramebufferEXT(gl::FRAMEBUFFER_EXT, 0); }
+                unsafe {
+                    ctxt.gl.BindFramebufferEXT(gl::FRAMEBUFFER_EXT, 0);
+                }
                 ctxt.state.draw_framebuffer = 0;
                 ctxt.state.read_framebuffer = 0;
             } else {
@@ -344,7 +369,10 @@ impl Context {
     /// Returns true if the given GLSL version is supported.
     #[inline]
     pub fn is_glsl_version_supported(&self, version: &Version) -> bool {
-        self.capabilities().supported_glsl_versions.iter().any(|v| v == version)
+        self.capabilities()
+            .supported_glsl_versions
+            .iter()
+            .any(|v| v == version)
     }
 
     /// Returns a string containing this GL version or release number used by this context.
@@ -421,9 +449,9 @@ impl Context {
 
         let mut ctxt = self.make_current();
 
-        let lost = if ctxt.version >= &Version(Api::Gl, 4, 5) ||
-                      ctxt.version >= &Version(Api::GlEs, 3, 2) ||
-                      ctxt.extensions.gl_khr_robustness
+        let lost = if ctxt.version >= &Version(Api::Gl, 4, 5)
+            || ctxt.version >= &Version(Api::GlEs, 3, 2)
+            || ctxt.extensions.gl_khr_robustness
         {
             unsafe { ctxt.gl.GetGraphicsResetStatus() != gl::NO_ERROR }
         } else if ctxt.extensions.gl_ext_robustness {
@@ -434,7 +462,9 @@ impl Context {
             false
         };
 
-        if lost { ctxt.state.lost_context = true; }
+        if lost {
+            ctxt.state.lost_context = true;
+        }
         lost
     }
 
@@ -451,7 +481,9 @@ impl Context {
     /// if the hardware doesn't support it.
     #[inline]
     pub fn get_max_anisotropy_support(&self) -> Option<u16> {
-        self.capabilities().max_texture_max_anisotropy.map(|v| v as u16)
+        self.capabilities()
+            .max_texture_max_anisotropy
+            .map(|v| v as u16)
     }
 
     /// Returns the maximum dimensions of the viewport.
@@ -470,8 +502,10 @@ impl Context {
         unsafe {
             let ctxt = self.make_current();
 
-            if (ctxt.version >= &Version(Api::GlEs, 2, 0) ||
-                ctxt.version >= &Version(Api::Gl, 4, 1)) && !ctxt.capabilities.supported_glsl_versions.is_empty() {
+            if (ctxt.version >= &Version(Api::GlEs, 2, 0)
+                || ctxt.version >= &Version(Api::Gl, 4, 1))
+                && !ctxt.capabilities.supported_glsl_versions.is_empty()
+            {
                 ctxt.gl.ReleaseShaderCompiler();
             }
         }
@@ -487,14 +521,15 @@ impl Context {
             let mut value: [gl::types::GLint; 4] = [0; 4];
 
             if ctxt.extensions.gl_nvx_gpu_memory_info {
-                ctxt.gl.GetIntegerv(gl::GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX,
-                               &mut value[0]);
+                ctxt.gl.GetIntegerv(
+                    gl::GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX,
+                    &mut value[0],
+                );
                 Some(value[0] as usize * 1024)
-
             } else if ctxt.extensions.gl_ati_meminfo {
-                ctxt.gl.GetIntegerv(gl::TEXTURE_FREE_MEMORY_ATI, &mut value[0]);
+                ctxt.gl
+                    .GetIntegerv(gl::TEXTURE_FREE_MEMORY_ATI, &mut value[0]);
                 Some(value[0] as usize * 1024)
-
             } else {
                 None
             }
@@ -516,15 +551,26 @@ impl Context {
     /// # }
     /// ```
     pub fn read_front_buffer<T>(&self) -> Result<T, ops::ReadError>
-        where T: texture::Texture2dDataSink<(u8, u8, u8, u8)>
+    where
+        T: texture::Texture2dDataSink<(u8, u8, u8, u8)>,
     {
         let mut ctxt = self.make_current();
         let dimensions = self.get_framebuffer_dimensions();
-        let rect = crate::Rect { left: 0, bottom: 0, width: dimensions.0, height: dimensions.1 };
+        let rect = crate::Rect {
+            left: 0,
+            bottom: 0,
+            width: dimensions.0,
+            height: dimensions.1,
+        };
 
         let mut data = Vec::with_capacity(0);
-        ops::read(&mut ctxt, ops::Source::DefaultFramebuffer(gl::FRONT_LEFT), &rect,
-                          &mut data, false)?;
+        ops::read(
+            &mut ctxt,
+            ops::Source::DefaultFramebuffer(gl::FRONT_LEFT),
+            &rect,
+            &mut data,
+            false,
+        )?;
         Ok(T::from_raw(Cow::Owned(data), dimensions.0, dimensions.1))
     }
 
@@ -535,13 +581,30 @@ impl Context {
     /// completes.**
     #[inline]
     pub unsafe fn exec_in_context<'a, T, F>(&self, action: F) -> T
-                                            where T: Send + 'static,
-                                            F: FnOnce() -> T + 'a
+    where
+        T: Send + 'static,
+        F: FnOnce() -> T + 'a,
     {
         let _ctxt = self.make_current();
         action()
     }
 
+    /// Execute an arbitrary closure with the OpenGL context active and mutable access to
+    /// glium's internal state. Useful if another component needs to directly manipulate
+    /// OpenGL state or if another component already has.
+    ///
+    /// **`action` takes full responsibility for keeping OpenGL state in sync with the
+    /// context's state.**
+    #[inline]
+    pub unsafe fn exec_with_context<'a, T, F>(&self, action: F) -> T
+    where
+        T: Send + 'static,
+        F: FnOnce(&mut CommandContext<'_>) -> T + 'a,
+    {
+        let mut ctxt = self.make_current();
+        action(&mut ctxt)
+    }
+
     /// Asserts that there are no OpenGL errors pending.
     ///
     /// This function should be used in tests.
@@ -551,7 +614,7 @@ impl Context {
         match (crate::get_gl_error(&mut ctxt), user_msg) {
             (Some(msg), None) => panic!("{}", msg),
             (Some(msg), Some(user_msg)) => panic!("{} : {}", user_msg, msg),
-            (None, _) => ()
+            (None, _) => (),
         };
     }
 
@@ -572,7 +635,9 @@ impl Context {
     #[inline]
     pub fn finish(&self) {
         let ctxt = self.make_current();
-        unsafe { ctxt.gl.Finish(); }
+        unsafe {
+            ctxt.gl.Finish();
+        }
     }
 
     /// Calls `glFlush()`. This starts executing the commands that you have issued if it is not
@@ -587,7 +652,9 @@ impl Context {
     #[inline]
     pub fn flush(&self) {
         let ctxt = self.make_current();
-        unsafe { ctxt.gl.Flush(); }
+        unsafe {
+            ctxt.gl.Flush();
+        }
     }
 
     /// Inserts a debugging string in the commands queue. If you use an OpenGL debugger, you will
@@ -602,16 +669,22 @@ impl Context {
 
         if ctxt.extensions.gl_gremedy_string_marker {
             let marker = marker.as_bytes();
-            unsafe { ctxt.gl.StringMarkerGREMEDY(marker.len() as gl::types::GLsizei,
-                                                 marker.as_ptr() as *const _) };
+            unsafe {
+                ctxt.gl.StringMarkerGREMEDY(
+                    marker.len() as gl::types::GLsizei,
+                    marker.as_ptr() as *const _,
+                )
+            };
             Ok(())
-
         } else if ctxt.extensions.gl_ext_debug_marker {
             let marker = marker.as_bytes();
-            unsafe { ctxt.gl.InsertEventMarkerEXT(marker.len() as gl::types::GLsizei,
-                                                  marker.as_ptr() as *const _) };
+            unsafe {
+                ctxt.gl.InsertEventMarkerEXT(
+                    marker.len() as gl::types::GLsizei,
+                    marker.as_ptr() as *const _,
+                )
+            };
             Ok(())
-
         } else {
             Err(())
         }
@@ -713,17 +786,19 @@ impl Drop for Context {
             fbo::FramebuffersContainer::cleanup(&mut ctxt);
             vertex_array_object::VertexAttributesSystem::cleanup(&mut ctxt);
 
-            for (_, s) in mem::replace(&mut *ctxt.samplers, HashMap::with_hasher(Default::default())) {
+            for (_, s) in mem::replace(
+                &mut *ctxt.samplers,
+                HashMap::with_hasher(Default::default()),
+            ) {
                 s.destroy(&mut ctxt);
             }
 
             // disabling callback
             if ctxt.state.enabled_debug_output != Some(false) {
-                if ctxt.version >= &Version(Api::Gl, 4,5) || ctxt.extensions.gl_khr_debug {
+                if ctxt.version >= &Version(Api::Gl, 4, 5) || ctxt.extensions.gl_khr_debug {
                     ctxt.gl.Disable(gl::DEBUG_OUTPUT);
                 } else if ctxt.extensions.gl_arb_debug_output {
-                    ctxt.gl.DebugMessageCallbackARB(None,
-                                                    ptr::null());
+                    ctxt.gl.DebugMessageCallbackARB(None, ptr::null());
                 }
 
                 ctxt.state.enabled_debug_output = Some(false);
@@ -751,34 +826,39 @@ impl<'a> CapabilitiesSource for CommandContext<'a> {
 }
 
 /// Checks whether the backend supports glium. Returns an `Err` if it doesn't.
-fn check_gl_compatibility(version: &Version, extensions: &ExtensionsList)
-    -> Result<(), IncompatibleOpenGl>
-{
+fn check_gl_compatibility(
+    version: &Version,
+    extensions: &ExtensionsList,
+) -> Result<(), IncompatibleOpenGl> {
     let mut result = Vec::with_capacity(0);
 
-    if !(version >= &Version(Api::Gl, 1, 5)) &&
-        !(version >= &Version(Api::GlEs, 2, 0)) &&
-        (!extensions.gl_arb_vertex_buffer_object || !extensions.gl_arb_map_buffer_range)
+    if !(version >= &Version(Api::Gl, 1, 5))
+        && !(version >= &Version(Api::GlEs, 2, 0))
+        && (!extensions.gl_arb_vertex_buffer_object || !extensions.gl_arb_map_buffer_range)
     {
         result.push("OpenGL implementation doesn't support buffer objects");
     }
 
-    if !(version >= &Version(Api::Gl, 2, 0)) &&
-        !(version >= &Version(Api::GlEs, 2, 0)) &&
-        (!extensions.gl_arb_shader_objects ||
-            !extensions.gl_arb_vertex_shader || !extensions.gl_arb_fragment_shader)
+    if !(version >= &Version(Api::Gl, 2, 0))
+        && !(version >= &Version(Api::GlEs, 2, 0))
+        && (!extensions.gl_arb_shader_objects
+            || !extensions.gl_arb_vertex_shader
+            || !extensions.gl_arb_fragment_shader)
     {
         result.push("OpenGL implementation doesn't support vertex/fragment shaders");
     }
 
-    if !extensions.gl_ext_framebuffer_object && !(version >= &Version(Api::Gl, 3, 0)) &&
-        !(version >= &Version(Api::GlEs, 2, 0)) && !extensions.gl_arb_framebuffer_object
+    if !extensions.gl_ext_framebuffer_object
+        && !(version >= &Version(Api::Gl, 3, 0))
+        && !(version >= &Version(Api::GlEs, 2, 0))
+        && !extensions.gl_arb_framebuffer_object
     {
         result.push("OpenGL implementation doesn't support framebuffers");
     }
 
-    if !extensions.gl_ext_framebuffer_blit && !(version >= &Version(Api::Gl, 3, 0)) &&
-        !(version >= &Version(Api::GlEs, 2, 0))
+    if !extensions.gl_ext_framebuffer_blit
+        && !(version >= &Version(Api::Gl, 3, 0))
+        && !(version >= &Version(Api::GlEs, 2, 0))
     {
         result.push("OpenGL implementation doesn't support blitting framebuffers");
     }
@@ -823,13 +903,18 @@ impl Default for DebugCallbackBehavior {
 }
 
 /// The callback corresponding to `DebugMessageOnError`.
-fn default_debug_callback(_: debug::Source, ty: debug::MessageType, severity: debug::Severity,
-                          _: u32, report_debug_output_errors: bool, message: &str)
-{
+fn default_debug_callback(
+    _: debug::Source,
+    ty: debug::MessageType,
+    severity: debug::Severity,
+    _: u32,
+    report_debug_output_errors: bool,
+    message: &str,
+) {
     match severity {
         debug::Severity::Medium => (),
         debug::Severity::High => (),
-        _ => return
+        _ => return,
     };
 
     match ty {
@@ -841,10 +926,12 @@ fn default_debug_callback(_: debug::Source, ty: debug::MessageType, severity: de
     };
 
     if report_debug_output_errors {
-        eprint!("Debug message with high or medium severity: `{}`.\n\
+        eprint!(
+            "Debug message with high or medium severity: `{}`.\n\
                  Please report this error: https://github.com/glium/glium/issues\n\
                  Backtrace:",
-                 message);
+            message
+        );
 
         let mut frame_id = 1;
         backtrace::trace(|frame| {
@@ -852,14 +939,18 @@ fn default_debug_callback(_: debug::Source, ty: debug::MessageType, severity: de
             print!("\n{:>#4} - {:p}", frame_id, ip);
 
             backtrace::resolve(ip, |symbol| {
-                let name = symbol.name()
-                                 .map(|n| n.as_str().unwrap_or("<not-utf8>"))
-                                 .unwrap_or("<unknown>");
-                let filename = symbol.filename()
-                                     .map(|p| p.to_str().unwrap_or("<not-utf8>"))
-                                     .unwrap_or("<unknown>");
-                let line = symbol.lineno().map(|l| l.to_string())
-                                          .unwrap_or_else(|| "??".to_owned());
+                let name = symbol
+                    .name()
+                    .map(|n| n.as_str().unwrap_or("<not-utf8>"))
+                    .unwrap_or("<unknown>");
+                let filename = symbol
+                    .filename()
+                    .map(|p| p.to_str().unwrap_or("<not-utf8>"))
+                    .unwrap_or("<unknown>");
+                let line = symbol
+                    .lineno()
+                    .map(|l| l.to_string())
+                    .unwrap_or_else(|| "??".to_owned());
 
                 print!("\n         {} at {}:{}", name, filename, line);
             });
@@ -873,23 +964,37 @@ fn default_debug_callback(_: debug::Source, ty: debug::MessageType, severity: de
 }
 
 /// The callback corresponding to `DebugMessageOnError`.
-fn printall_debug_callback(source: debug::Source, ty: debug::MessageType, severity: debug::Severity,
-                           id: u32, _: bool, message: &str)
-{
-    eprintln!("Source: {src:?}\t\tSeverity: {sev:?}\t\tType: {ty:?}\t\tId: {id}\n{msg}",
-               src = source, sev = severity, ty = ty, id = id, msg = message);
+fn printall_debug_callback(
+    source: debug::Source,
+    ty: debug::MessageType,
+    severity: debug::Severity,
+    id: u32,
+    _: bool,
+    message: &str,
+) {
+    eprintln!(
+        "Source: {src:?}\t\tSeverity: {sev:?}\t\tType: {ty:?}\t\tId: {id}\n{msg}",
+        src = source,
+        sev = severity,
+        ty = ty,
+        id = id,
+        msg = message
+    );
 }
 
 /// Initializes `GL_KHR_debug`, `GL_ARB_debug`, or a similar extension so that the debug output
 /// is reported.
 fn init_debug_callback(context: &Rc<Context>, synchronous: bool) {
     // this is the C callback
-    extern "system" fn callback_wrapper(source: gl::types::GLenum, ty: gl::types::GLenum,
-                                        id: gl::types::GLuint, severity: gl::types::GLenum,
-                                        _length: gl::types::GLsizei,
-                                        message: *const gl::types::GLchar,
-                                        user_param: *mut raw::c_void)
-    {
+    extern "system" fn callback_wrapper(
+        source: gl::types::GLenum,
+        ty: gl::types::GLenum,
+        id: gl::types::GLuint,
+        severity: gl::types::GLenum,
+        _length: gl::types::GLsizei,
+        message: *const gl::types::GLchar,
+        user_param: *mut raw::c_void,
+    ) {
         // note that we transmute the user param into a proper context
         // in order to enforce safety here, the context disables debug output and flushes in its
         // destructor
@@ -897,16 +1002,15 @@ fn init_debug_callback(context: &Rc<Context>, synchronous: bool) {
         let user_param = user_param as *const Context;
         let user_param: &mut Context = unsafe { mem::transmute(user_param) };
 
-        let message = unsafe {
-            String::from_utf8(CStr::from_ptr(message).to_bytes().to_vec()).unwrap()
-        };
+        let message =
+            unsafe { String::from_utf8(CStr::from_ptr(message).to_bytes().to_vec()).unwrap() };
 
         let severity = match severity {
             gl::DEBUG_SEVERITY_NOTIFICATION => debug::Severity::Notification,
             gl::DEBUG_SEVERITY_LOW => debug::Severity::Low,
             gl::DEBUG_SEVERITY_MEDIUM => debug::Severity::Medium,
             gl::DEBUG_SEVERITY_HIGH => debug::Severity::High,
-            _ => return,        // TODO: what to do in this situation?
+            _ => return, // TODO: what to do in this situation?
         };
 
         let source = match source {
@@ -916,7 +1020,7 @@ fn init_debug_callback(context: &Rc<Context>, synchronous: bool) {
             gl::DEBUG_SOURCE_THIRD_PARTY => debug::Source::ThirdParty,
             gl::DEBUG_SOURCE_APPLICATION => debug::Source::Application,
             gl::DEBUG_SOURCE_OTHER => debug::Source::OtherSource,
-            _ => return,        // TODO: what to do in this situation?
+            _ => return, // TODO: what to do in this situation?
         };
 
         let ty = match ty {
@@ -929,13 +1033,19 @@ fn init_debug_callback(context: &Rc<Context>, synchronous: bool) {
             gl::DEBUG_TYPE_PUSH_GROUP => debug::MessageType::PushGroup,
             gl::DEBUG_TYPE_POP_GROUP => debug::MessageType::PopGroup,
             gl::DEBUG_TYPE_OTHER => debug::MessageType::Other,
-            _ => return,        // TODO: what to do in this situation?
+            _ => return, // TODO: what to do in this situation?
         };
 
         if let Some(callback) = user_param.debug_callback.as_mut() {
             // FIXME: catch_panic here once it's stable
-            callback(source, ty, severity, id, user_param.report_debug_output_errors.get(),
-                     &message);
+            callback(
+                source,
+                ty,
+                severity,
+                id,
+                user_param.report_debug_output_errors.get(),
+                &message,
+            );
         }
     }
 
@@ -946,46 +1056,62 @@ fn init_debug_callback(context: &Rc<Context>, synchronous: bool) {
     unsafe {
         let mut ctxt = context.make_current();
 
-        if ctxt.version >= &Version(Api::Gl, 4,5) || ctxt.version >= &Version(Api::GlEs, 3, 2) ||
-           ctxt.extensions.gl_khr_debug || ctxt.extensions.gl_arb_debug_output
+        if ctxt.version >= &Version(Api::Gl, 4, 5)
+            || ctxt.version >= &Version(Api::GlEs, 3, 2)
+            || ctxt.extensions.gl_khr_debug
+            || ctxt.extensions.gl_arb_debug_output
         {
             if synchronous && !ctxt.state.enabled_debug_output_synchronous {
                 ctxt.gl.Enable(gl::DEBUG_OUTPUT_SYNCHRONOUS);
                 ctxt.state.enabled_debug_output_synchronous = true;
             }
 
-            if ctxt.version >= &Version(Api::Gl, 4, 5) ||
-               ctxt.version >= &Version(Api::GlEs, 3, 2) ||
-               (ctxt.version >= &Version(Api::Gl, 1, 0) && ctxt.extensions.gl_khr_debug)
+            if ctxt.version >= &Version(Api::Gl, 4, 5)
+                || ctxt.version >= &Version(Api::GlEs, 3, 2)
+                || (ctxt.version >= &Version(Api::Gl, 1, 0) && ctxt.extensions.gl_khr_debug)
             {
-                ctxt.gl.DebugMessageCallback(Some(callback_wrapper), context_raw_ptr.0
-                                                                     as *const _);
-                ctxt.gl.DebugMessageControl(gl::DONT_CARE, gl::DONT_CARE, gl::DONT_CARE, 0,
-                                            ptr::null(), gl::TRUE);
+                ctxt.gl
+                    .DebugMessageCallback(Some(callback_wrapper), context_raw_ptr.0 as *const _);
+                ctxt.gl.DebugMessageControl(
+                    gl::DONT_CARE,
+                    gl::DONT_CARE,
+                    gl::DONT_CARE,
+                    0,
+                    ptr::null(),
+                    gl::TRUE,
+                );
 
                 if ctxt.state.enabled_debug_output != Some(true) {
                     ctxt.gl.Enable(gl::DEBUG_OUTPUT);
                     ctxt.state.enabled_debug_output = Some(true);
                 }
-
-            } else if ctxt.version >= &Version(Api::GlEs, 2, 0) &&
-                      ctxt.extensions.gl_khr_debug
-            {
-                ctxt.gl.DebugMessageCallbackKHR(Some(callback_wrapper), context_raw_ptr.0
-                                                                        as *const _);
-                ctxt.gl.DebugMessageControlKHR(gl::DONT_CARE, gl::DONT_CARE, gl::DONT_CARE, 0,
-                                               ptr::null(), gl::TRUE);
+            } else if ctxt.version >= &Version(Api::GlEs, 2, 0) && ctxt.extensions.gl_khr_debug {
+                ctxt.gl
+                    .DebugMessageCallbackKHR(Some(callback_wrapper), context_raw_ptr.0 as *const _);
+                ctxt.gl.DebugMessageControlKHR(
+                    gl::DONT_CARE,
+                    gl::DONT_CARE,
+                    gl::DONT_CARE,
+                    0,
+                    ptr::null(),
+                    gl::TRUE,
+                );
 
                 if ctxt.state.enabled_debug_output != Some(true) {
                     ctxt.gl.Enable(gl::DEBUG_OUTPUT);
                     ctxt.state.enabled_debug_output = Some(true);
                 }
-
             } else {
-                ctxt.gl.DebugMessageCallbackARB(Some(callback_wrapper), context_raw_ptr.0
-                                                                        as *const _);
-                ctxt.gl.DebugMessageControlARB(gl::DONT_CARE, gl::DONT_CARE, gl::DONT_CARE,
-                                               0, ptr::null(), gl::TRUE);
+                ctxt.gl
+                    .DebugMessageCallbackARB(Some(callback_wrapper), context_raw_ptr.0 as *const _);
+                ctxt.gl.DebugMessageControlARB(
+                    gl::DONT_CARE,
+                    gl::DONT_CARE,
+                    gl::DONT_CARE,
+                    0,
+                    ptr::null(),
+                    gl::TRUE,
+                );
 
                 ctxt.state.enabled_debug_output = Some(true);
             }
diff --git a/src/framebuffer/mod.rs b/src/framebuffer/mod.rs
index 26a6513..0f618c9 100644
--- a/src/framebuffer/mod.rs
+++ b/src/framebuffer/mod.rs
@@ -134,7 +134,7 @@ impl<'a> SimpleFrameBuffer<'a> {
                                     Some(depth.to_depth_attachment()), None, None)
     }
 
-    /// Creates a `SimpleFrameBuffer` with a single color attachment and no depth
+    /// Creates a `SimpleFrameBuffer` with a depth buffer and no color attachment
     /// nor stencil buffer.
     #[inline]
     pub fn depth_only<F: ?Sized, D>(facade: &F, depth: D)
@@ -160,8 +160,8 @@ impl<'a> SimpleFrameBuffer<'a> {
                                     Some(stencil.to_stencil_attachment()), None)
     }
 
-    /// Creates a `SimpleFrameBuffer` with a single color attachment and no depth
-    /// nor stencil buffer.
+    /// Creates a `SimpleFrameBuffer` with a depth buffer and a stencil buffer,
+    /// but no color attachment.
     #[inline]
     pub fn depth_and_stencil_only<F: ?Sized, D, S>(facade: &F, depth: D, stencil: S)
                                            -> Result<SimpleFrameBuffer<'a>, ValidationError>
@@ -184,8 +184,8 @@ impl<'a> SimpleFrameBuffer<'a> {
                                     Some(stencil.to_stencil_attachment()), None)
     }
 
-    /// Creates a `SimpleFrameBuffer` with a single color attachment and a stencil
-    /// buffer, but no depth buffer.
+    /// Creates a `SimpleFrameBuffer` with a stencil buffer and no color attachment
+    /// nor depth buffer.
     #[inline]
     pub fn stencil_only<F: ?Sized, S>(facade: &F, stencil: S)
                               -> Result<SimpleFrameBuffer<'a>, ValidationError>
@@ -206,7 +206,7 @@ impl<'a> SimpleFrameBuffer<'a> {
                                     Some(depthstencil.to_depth_stencil_attachment()))
     }
 
-    /// Creates a `SimpleFrameBuffer` with a single color attachment and a depth-stencil buffer.
+    /// Creates a `SimpleFrameBuffer` with a depth-stencil buffer and no color attachment.
     #[inline]
     pub fn depth_stencil_only<F: ?Sized, D>(facade: &F, depthstencil: D)
                                     -> Result<SimpleFrameBuffer<'a>, ValidationError>
@@ -354,7 +354,7 @@ impl<'a> FboAttachments for SimpleFrameBuffer<'a> {
     }
 }
 
-/// This struct is useless for the moment.
+/// A framebuffer which has multiple color attachments.
 pub struct MultiOutputFrameBuffer<'a> {
     context: Rc<Context>,
     example_attachments: fbo::ValidatedAttachments<'a>,
diff --git a/src/image_format.rs b/src/image_format.rs
index 4af19b7..e7a9553 100644
--- a/src/image_format.rs
+++ b/src/image_format.rs
@@ -1034,13 +1034,13 @@ pub enum CompressedFormat {
     /// BPTC format with three components (no alpha) represented as unsigned floats.
     BptcUnsignedFloat3,
 
-    /// S3TC DXT1 without alpha, see https://www.opengl.org/wiki/S3_Texture_Compression.
+    /// S3TC DXT1 without alpha, see <https://www.opengl.org/wiki/S3_Texture_Compression>.
     S3tcDxt1NoAlpha,
-    /// S3TC DXT1 with 1-bit alpha, see https://www.opengl.org/wiki/S3_Texture_Compression.
+    /// S3TC DXT1 with 1-bit alpha, see <https://www.opengl.org/wiki/S3_Texture_Compression>.
     S3tcDxt1Alpha,
-    /// S3TC DXT3, see https://www.opengl.org/wiki/S3_Texture_Compression.
+    /// S3TC DXT3, see <https://www.opengl.org/wiki/S3_Texture_Compression>.
     S3tcDxt3Alpha,
-    /// S3TC DXT5, see https://www.opengl.org/wiki/S3_Texture_Compression.
+    /// S3TC DXT5, see <https://www.opengl.org/wiki/S3_Texture_Compression>.
     S3tcDxt5Alpha,
 }
 
diff --git a/src/lib.rs b/src/lib.rs
index f83cdbf..af8e9b9 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -4,7 +4,7 @@ Easy-to-use, high-level, OpenGL3+ wrapper.
 Glium is based on glutin - a cross-platform crate for building an OpenGL window and handling
 application events.
 
-Glium provides a [**Display**](`Display`) which extends the [**glutin::WindowedContext**](`glutin::WindowedContext`) with a high-level, safe API.
+Glium provides a [`Display`] which uses `glutin` for the Window and its associated GL Context.
 
 # Initialization
 
@@ -16,7 +16,7 @@ extern crate winit;
 
 fn main() {
     // 1. The **winit::EventLoop** for handling events.
-    let event_loop = winit::event_loop::EventLoopBuilder::new().build();
+    let event_loop = winit::event_loop::EventLoopBuilder::new().build().unwrap();
     // 2. Create a glutin context and glium Display
     let (window, display) = glium::backend::glutin::SimpleWindowBuilder::new().build(&event_loop);
 }
@@ -106,15 +106,12 @@ result to the user.
     clippy::wrong_self_convention,
 )]
 
-#[macro_use]
-extern crate lazy_static;
-
 #[cfg(feature = "glutin")]
 pub use crate::backend::glutin::glutin;
-pub use crate::context::{Profile, UuidError};
+pub use crate::context::{Capabilities, ExtensionsList, Profile, UuidError};
 pub use crate::draw_parameters::{Blend, BlendingFunction, LinearBlendingFactor, BackfaceCullingMode};
 pub use crate::draw_parameters::{Depth, DepthTest, PolygonMode, DrawParameters, StencilTest, StencilOperation};
-pub use crate::draw_parameters::{Smooth};
+pub use crate::draw_parameters::Smooth;
 pub use crate::index::IndexBuffer;
 pub use crate::vertex::{VertexBuffer, Vertex, VertexFormat};
 pub use crate::program::{Program, ProgramCreationError};
diff --git a/src/program/mod.rs b/src/program/mod.rs
index 9a2cd45..6ddf3e1 100644
--- a/src/program/mod.rs
+++ b/src/program/mod.rs
@@ -57,10 +57,7 @@ pub fn is_subroutine_supported<C: ?Sized>(ctxt: &C) -> bool where C: Capabilitie
 
 // Some shader compilers have race-condition issues, so we lock this mutex
 // in the GL thread every time we compile a shader or link a program.
-// TODO: replace by a StaticMutex
-lazy_static! {
-    static ref COMPILER_GLOBAL_LOCK: Mutex<()> = Mutex::new(());
-}
+static COMPILER_GLOBAL_LOCK: Mutex<()> = Mutex::new(());
 
 /// Used in ProgramCreationError::CompilationError to explain which shader stage failed compilation
 #[derive(Copy, Clone, Debug, PartialEq, Eq)]
@@ -278,7 +275,7 @@ pub enum ProgramCreationInput<'a> {
         /// The data.
         data: Binary,
 
-        /// See `SourceCode::outputs_srgb`.
+        /// See [`ProgramCreationInput::SourceCode::outputs_srgb`].
         outputs_srgb: bool,
 
         /// Whether the shader uses point size.
@@ -313,7 +310,7 @@ pub struct SpirvProgram<'a> {
     /// `None`, then you won't be able to use transform feedback.
     pub transform_feedback_varyings: Option<(Vec<String>, TransformFeedbackMode)>,
 
-    /// See `SourceCode::outputs_srgb`.
+    /// See [`ProgramCreationInput::SourceCode::outputs_srgb`].
     pub outputs_srgb: bool,
 
     /// Whether the shader uses point size.
diff --git a/src/semaphore.rs b/src/semaphore.rs
index 7efb633..d60241f 100644
--- a/src/semaphore.rs
+++ b/src/semaphore.rs
@@ -39,7 +39,7 @@ impl std::fmt::Display for SemaphoreCreationError {
 
 impl std::error::Error for SemaphoreCreationError {}
 
-/// Describes a Vulkan image layout that a texture can be in. See https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageLayout.html
+/// Describes a Vulkan image layout that a texture can be in. See <https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkImageLayout.html>
 #[derive(Debug, Clone, Copy)]
 pub enum TextureLayout {
     /// Corresponds to VK_IMAGE_LAYOUT_UNDEFINED
diff --git a/src/texture/mod.rs b/src/texture/mod.rs
index 4075491..3c1ad76 100644
--- a/src/texture/mod.rs
+++ b/src/texture/mod.rs
@@ -524,7 +524,7 @@ impl<'a, T: Clone + 'a> RawImage2d<'a, T> {
         RawImage2d::from_raw_rgba(data, dimensions)
     }
 
-    ///Transforms a Vec<RawImage1d> into a RawImage2d
+    /// Transforms a `Vec<RawImage1d>` into a `RawImage2d`
     pub fn from_vec_raw1d(arr: &Vec<RawImage1d<'a, T>>) -> RawImage2d<'a, T> {
         let width   = arr[0].width;
         let height  = arr.len() as u32;
@@ -728,7 +728,7 @@ pub struct RawImage3d<'a, T: Clone> {
 }
 
 impl<'a, T: Clone + 'a> RawImage3d<'a, T> {
-    ///Transforms a Vec<RawImage2d> into a RawImage3d
+    /// Transforms a `Vec<RawImage2d>` into a `RawImage3d`
     pub fn from_vec_raw2d(arr: &Vec<RawImage2d<'a, T>>) -> RawImage3d<'a, T> {
         let depth   = arr.len() as u32;
         let width   = arr[0].width;
diff --git a/src/uniforms/value.rs b/src/uniforms/value.rs
index cc394be..173f9f0 100644
--- a/src/uniforms/value.rs
+++ b/src/uniforms/value.rs
@@ -5,11 +5,12 @@ use crate::texture;
 
 use crate::uniforms::AsUniformValue;
 use crate::uniforms::LayoutMismatchError;
-use crate::uniforms::SamplerBehavior;
 use crate::uniforms::UniformBlock;
+use crate::uniforms::SamplerBehavior;
 
-use crate::buffer::BufferAnySlice;
 use crate::uniforms::ImageUnitBehavior;
+use crate::buffer::BufferAnySlice;
+
 
 /// Type of a uniform in a program.
 #[allow(missing_docs)]
@@ -145,10 +146,7 @@ pub enum UniformValue<'a> {
     /// can be bound on a block with the given layout.
     /// The last parameter is a sender which must be used to send a `SyncFence` that expires when
     /// the buffer has finished being used.
-    Block(
-        BufferAnySlice<'a>,
-        fn(&program::UniformBlock) -> Result<(), LayoutMismatchError>,
-    ),
+    Block(BufferAnySlice<'a>, fn(&program::UniformBlock) -> Result<(), LayoutMismatchError>),
     Subroutine(ShaderStage, &'a str),
     SignedInt(i32),
     UnsignedInt(u32),
@@ -176,9 +174,9 @@ pub enum UniformValue<'a> {
     DoubleVec2([f64; 2]),
     DoubleVec3([f64; 3]),
     DoubleVec4([f64; 4]),
-    DoubleMat2([[f64; 2]; 2]),
-    DoubleMat3([[f64; 3]; 3]),
-    DoubleMat4([[f64; 4]; 4]),
+    DoubleMat2([[f64;2]; 2]),
+    DoubleMat3([[f64;3]; 3]),
+    DoubleMat4([[f64;4]; 4]),
     Int64(i64),
     Int64Vec2([i64; 2]),
     Int64Vec3([i64; 3]),
@@ -190,96 +188,48 @@ pub enum UniformValue<'a> {
     Texture1d(&'a texture::Texture1d, Option<SamplerBehavior>),
     CompressedTexture1d(&'a texture::CompressedTexture1d, Option<SamplerBehavior>),
     SrgbTexture1d(&'a texture::SrgbTexture1d, Option<SamplerBehavior>),
-    CompressedSrgbTexture1d(
-        &'a texture::CompressedSrgbTexture1d,
-        Option<SamplerBehavior>,
-    ),
+    CompressedSrgbTexture1d(&'a texture::CompressedSrgbTexture1d, Option<SamplerBehavior>),
     IntegralTexture1d(&'a texture::IntegralTexture1d, Option<SamplerBehavior>),
     UnsignedTexture1d(&'a texture::UnsignedTexture1d, Option<SamplerBehavior>),
     DepthTexture1d(&'a texture::DepthTexture1d, Option<SamplerBehavior>),
     Texture2d(&'a texture::Texture2d, Option<SamplerBehavior>),
     CompressedTexture2d(&'a texture::CompressedTexture2d, Option<SamplerBehavior>),
     SrgbTexture2d(&'a texture::SrgbTexture2d, Option<SamplerBehavior>),
-    CompressedSrgbTexture2d(
-        &'a texture::CompressedSrgbTexture2d,
-        Option<SamplerBehavior>,
-    ),
+    CompressedSrgbTexture2d(&'a texture::CompressedSrgbTexture2d, Option<SamplerBehavior>),
     IntegralTexture2d(&'a texture::IntegralTexture2d, Option<SamplerBehavior>),
     UnsignedTexture2d(&'a texture::UnsignedTexture2d, Option<SamplerBehavior>),
     DepthTexture2d(&'a texture::DepthTexture2d, Option<SamplerBehavior>),
     Texture2dMultisample(&'a texture::Texture2dMultisample, Option<SamplerBehavior>),
-    SrgbTexture2dMultisample(
-        &'a texture::SrgbTexture2dMultisample,
-        Option<SamplerBehavior>,
-    ),
-    IntegralTexture2dMultisample(
-        &'a texture::IntegralTexture2dMultisample,
-        Option<SamplerBehavior>,
-    ),
-    UnsignedTexture2dMultisample(
-        &'a texture::UnsignedTexture2dMultisample,
-        Option<SamplerBehavior>,
-    ),
-    DepthTexture2dMultisample(
-        &'a texture::DepthTexture2dMultisample,
-        Option<SamplerBehavior>,
-    ),
+    SrgbTexture2dMultisample(&'a texture::SrgbTexture2dMultisample, Option<SamplerBehavior>),
+    IntegralTexture2dMultisample(&'a texture::IntegralTexture2dMultisample, Option<SamplerBehavior>),
+    UnsignedTexture2dMultisample(&'a texture::UnsignedTexture2dMultisample, Option<SamplerBehavior>),
+    DepthTexture2dMultisample(&'a texture::DepthTexture2dMultisample, Option<SamplerBehavior>),
     Texture3d(&'a texture::Texture3d, Option<SamplerBehavior>),
     CompressedTexture3d(&'a texture::CompressedTexture3d, Option<SamplerBehavior>),
     SrgbTexture3d(&'a texture::SrgbTexture3d, Option<SamplerBehavior>),
-    CompressedSrgbTexture3d(
-        &'a texture::CompressedSrgbTexture3d,
-        Option<SamplerBehavior>,
-    ),
+    CompressedSrgbTexture3d(&'a texture::CompressedSrgbTexture3d, Option<SamplerBehavior>),
     IntegralTexture3d(&'a texture::IntegralTexture3d, Option<SamplerBehavior>),
     UnsignedTexture3d(&'a texture::UnsignedTexture3d, Option<SamplerBehavior>),
     DepthTexture3d(&'a texture::DepthTexture3d, Option<SamplerBehavior>),
     Texture1dArray(&'a texture::Texture1dArray, Option<SamplerBehavior>),
-    CompressedTexture1dArray(
-        &'a texture::CompressedTexture1dArray,
-        Option<SamplerBehavior>,
-    ),
+    CompressedTexture1dArray(&'a texture::CompressedTexture1dArray, Option<SamplerBehavior>),
     SrgbTexture1dArray(&'a texture::SrgbTexture1dArray, Option<SamplerBehavior>),
-    CompressedSrgbTexture1dArray(
-        &'a texture::CompressedSrgbTexture1dArray,
-        Option<SamplerBehavior>,
-    ),
+    CompressedSrgbTexture1dArray(&'a texture::CompressedSrgbTexture1dArray, Option<SamplerBehavior>),
     IntegralTexture1dArray(&'a texture::IntegralTexture1dArray, Option<SamplerBehavior>),
     UnsignedTexture1dArray(&'a texture::UnsignedTexture1dArray, Option<SamplerBehavior>),
     DepthTexture1dArray(&'a texture::DepthTexture1dArray, Option<SamplerBehavior>),
     Texture2dArray(&'a texture::Texture2dArray, Option<SamplerBehavior>),
-    CompressedTexture2dArray(
-        &'a texture::CompressedTexture2dArray,
-        Option<SamplerBehavior>,
-    ),
+    CompressedTexture2dArray(&'a texture::CompressedTexture2dArray, Option<SamplerBehavior>),
     SrgbTexture2dArray(&'a texture::SrgbTexture2dArray, Option<SamplerBehavior>),
-    CompressedSrgbTexture2dArray(
-        &'a texture::CompressedSrgbTexture2dArray,
-        Option<SamplerBehavior>,
-    ),
+    CompressedSrgbTexture2dArray(&'a texture::CompressedSrgbTexture2dArray, Option<SamplerBehavior>),
     IntegralTexture2dArray(&'a texture::IntegralTexture2dArray, Option<SamplerBehavior>),
     UnsignedTexture2dArray(&'a texture::UnsignedTexture2dArray, Option<SamplerBehavior>),
     DepthTexture2dArray(&'a texture::DepthTexture2dArray, Option<SamplerBehavior>),
-    Texture2dMultisampleArray(
-        &'a texture::Texture2dMultisampleArray,
-        Option<SamplerBehavior>,
-    ),
-    SrgbTexture2dMultisampleArray(
-        &'a texture::SrgbTexture2dMultisampleArray,
-        Option<SamplerBehavior>,
-    ),
-    IntegralTexture2dMultisampleArray(
-        &'a texture::IntegralTexture2dMultisampleArray,
-        Option<SamplerBehavior>,
-    ),
-    UnsignedTexture2dMultisampleArray(
-        &'a texture::UnsignedTexture2dMultisampleArray,
-        Option<SamplerBehavior>,
-    ),
-    DepthTexture2dMultisampleArray(
-        &'a texture::DepthTexture2dMultisampleArray,
-        Option<SamplerBehavior>,
-    ),
+    Texture2dMultisampleArray(&'a texture::Texture2dMultisampleArray, Option<SamplerBehavior>),
+    SrgbTexture2dMultisampleArray(&'a texture::SrgbTexture2dMultisampleArray, Option<SamplerBehavior>),
+    IntegralTexture2dMultisampleArray(&'a texture::IntegralTexture2dMultisampleArray, Option<SamplerBehavior>),
+    UnsignedTexture2dMultisampleArray(&'a texture::UnsignedTexture2dMultisampleArray, Option<SamplerBehavior>),
+    DepthTexture2dMultisampleArray(&'a texture::DepthTexture2dMultisampleArray, Option<SamplerBehavior>),
     Cubemap(&'a texture::Cubemap, Option<SamplerBehavior>),
     CompressedCubemap(&'a texture::CompressedCubemap, Option<SamplerBehavior>),
     SrgbCubemap(&'a texture::SrgbCubemap, Option<SamplerBehavior>),
@@ -290,10 +240,7 @@ pub enum UniformValue<'a> {
     CubemapArray(&'a texture::CubemapArray, Option<SamplerBehavior>),
     CompressedCubemapArray(&'a texture::CompressedCubemapArray, Option<SamplerBehavior>),
     SrgbCubemapArray(&'a texture::SrgbCubemapArray, Option<SamplerBehavior>),
-    CompressedSrgbCubemapArray(
-        &'a texture::CompressedSrgbCubemapArray,
-        Option<SamplerBehavior>,
-    ),
+    CompressedSrgbCubemapArray(&'a texture::CompressedSrgbCubemapArray, Option<SamplerBehavior>),
     IntegralCubemapArray(&'a texture::IntegralCubemapArray, Option<SamplerBehavior>),
     UnsignedCubemapArray(&'a texture::UnsignedCubemapArray, Option<SamplerBehavior>),
     DepthCubemapArray(&'a texture::DepthCubemapArray, Option<SamplerBehavior>),
@@ -309,23 +256,11 @@ pub enum UniformValue<'a> {
     IntegralImage3d(&'a texture::IntegralTexture3d, Option<ImageUnitBehavior>),
     UnsignedImage3d(&'a texture::UnsignedTexture3d, Option<ImageUnitBehavior>),
     Image1dArray(&'a texture::Texture1dArray, Option<ImageUnitBehavior>),
-    IntegralImage1dArray(
-        &'a texture::IntegralTexture1dArray,
-        Option<ImageUnitBehavior>,
-    ),
-    UnsignedImage1dArray(
-        &'a texture::UnsignedTexture1dArray,
-        Option<ImageUnitBehavior>,
-    ),
+    IntegralImage1dArray(&'a texture::IntegralTexture1dArray, Option<ImageUnitBehavior>),
+    UnsignedImage1dArray(&'a texture::UnsignedTexture1dArray, Option<ImageUnitBehavior>),
     Image2dArray(&'a texture::Texture2dArray, Option<ImageUnitBehavior>),
-    IntegralImage2dArray(
-        &'a texture::IntegralTexture2dArray,
-        Option<ImageUnitBehavior>,
-    ),
-    UnsignedImage2dArray(
-        &'a texture::UnsignedTexture2dArray,
-        Option<ImageUnitBehavior>,
-    ),
+    IntegralImage2dArray(&'a texture::IntegralTexture2dArray, Option<ImageUnitBehavior>),
+    UnsignedImage2dArray(&'a texture::UnsignedTexture2dArray, Option<ImageUnitBehavior>),
     ImageCube(&'a texture::Cubemap, Option<ImageUnitBehavior>),
     IntegralImageCube(&'a texture::IntegralCubemap, Option<ImageUnitBehavior>),
     UnsignedImageCube(&'a texture::UnsignedCubemap, Option<ImageUnitBehavior>),
@@ -397,9 +332,7 @@ impl<'a> UniformValue<'a> {
             (&UniformValue::Texture1dArray(_, _), UniformType::Sampler1dArray) => true,
             (&UniformValue::CompressedTexture1dArray(_, _), UniformType::Sampler1dArray) => true,
             (&UniformValue::SrgbTexture1dArray(_, _), UniformType::Sampler1dArray) => true,
-            (&UniformValue::CompressedSrgbTexture1dArray(_, _), UniformType::Sampler1dArray) => {
-                true
-            }
+            (&UniformValue::CompressedSrgbTexture1dArray(_, _), UniformType::Sampler1dArray) => true,
             (&UniformValue::IntegralTexture1dArray(_, _), UniformType::ISampler1dArray) => true,
             (&UniformValue::UnsignedTexture1dArray(_, _), UniformType::USampler1dArray) => true,
             (&UniformValue::DepthTexture1dArray(_, _), UniformType::Sampler1dArray) => true,
@@ -407,9 +340,7 @@ impl<'a> UniformValue<'a> {
             (&UniformValue::Texture2dArray(_, _), UniformType::Sampler2dArray) => true,
             (&UniformValue::CompressedTexture2dArray(_, _), UniformType::Sampler2dArray) => true,
             (&UniformValue::SrgbTexture2dArray(_, _), UniformType::Sampler2dArray) => true,
-            (&UniformValue::CompressedSrgbTexture2dArray(_, _), UniformType::Sampler2dArray) => {
-                true
-            }
+            (&UniformValue::CompressedSrgbTexture2dArray(_, _), UniformType::Sampler2dArray) => true,
             (&UniformValue::IntegralTexture2dArray(_, _), UniformType::ISampler2dArray) => true,
             (&UniformValue::UnsignedTexture2dArray(_, _), UniformType::USampler2dArray) => true,
             (&UniformValue::DepthTexture2dArray(_, _), UniformType::Sampler2dArray) => true,
@@ -425,37 +356,25 @@ impl<'a> UniformValue<'a> {
             (&UniformValue::CubemapArray(_, _), UniformType::SamplerCubeArray) => true,
             (&UniformValue::CompressedCubemapArray(_, _), UniformType::SamplerCubeArray) => true,
             (&UniformValue::SrgbCubemapArray(_, _), UniformType::SamplerCubeArray) => true,
-            (&UniformValue::CompressedSrgbCubemapArray(_, _), UniformType::SamplerCubeArray) => {
-                true
-            }
+            (&UniformValue::CompressedSrgbCubemapArray(_, _), UniformType::SamplerCubeArray) => true,
             (&UniformValue::IntegralCubemapArray(_, _), UniformType::ISamplerCubeArray) => true,
             (&UniformValue::UnsignedCubemapArray(_, _), UniformType::USamplerCubeArray) => true,
             (&UniformValue::DepthCubemapArray(_, _), UniformType::SamplerCubeArray) => true,
             (&UniformValue::DepthCubemapArray(_, _), UniformType::SamplerCubeArrayShadow) => true,
             (&UniformValue::BufferTexture(tex), UniformType::SamplerBuffer) => {
                 tex.get_texture_type() == texture::buffer_texture::BufferTextureType::Float
-            }
+            },
             (&UniformValue::BufferTexture(tex), UniformType::ISamplerBuffer) => {
                 tex.get_texture_type() == texture::buffer_texture::BufferTextureType::Integral
-            }
+            },
             (&UniformValue::BufferTexture(tex), UniformType::USamplerBuffer) => {
                 tex.get_texture_type() == texture::buffer_texture::BufferTextureType::Unsigned
-            }
+            },
             (&UniformValue::Texture2dMultisample(..), UniformType::Sampler2dMultisample) => true,
-            (&UniformValue::SrgbTexture2dMultisample(..), UniformType::Sampler2dMultisample) => {
-                true
-            }
-            (
-                &UniformValue::IntegralTexture2dMultisample(..),
-                UniformType::ISampler2dMultisample,
-            ) => true,
-            (
-                &UniformValue::UnsignedTexture2dMultisample(..),
-                UniformType::USampler2dMultisample,
-            ) => true,
-            (&UniformValue::DepthTexture2dMultisample(..), UniformType::Sampler2dMultisample) => {
-                true
-            }
+            (&UniformValue::SrgbTexture2dMultisample(..), UniformType::Sampler2dMultisample) => true,
+            (&UniformValue::IntegralTexture2dMultisample(..), UniformType::ISampler2dMultisample) => true,
+            (&UniformValue::UnsignedTexture2dMultisample(..), UniformType::USampler2dMultisample) => true,
+            (&UniformValue::DepthTexture2dMultisample(..), UniformType::Sampler2dMultisample) => true,
             (&UniformValue::Image1d(..), UniformType::Image1d) => true,
             (&UniformValue::IntegralImage1d(..), UniformType::IImage1d) => true,
             (&UniformValue::UnsignedImage1d(..), UniformType::UImage1d) => true,
@@ -483,17 +402,12 @@ impl<'a> UniformValue<'a> {
 }
 
 macro_rules! impl_uniform_block_basic {
-    ($ty:ty, $uniform_ty:expr) => {
+    ($ty:ty, $uniform_ty:expr) => (
         impl UniformBlock for $ty {
-            fn matches(
-                layout: &program::BlockLayout,
-                base_offset: usize,
-            ) -> Result<(), LayoutMismatchError> {
-                if let &BlockLayout::BasicType {
-                    ty,
-                    offset_in_buffer,
-                } = layout
-                {
+            fn matches(layout: &program::BlockLayout, base_offset: usize)
+                       -> Result<(), LayoutMismatchError>
+            {
+                if let &BlockLayout::BasicType { ty, offset_in_buffer } = layout {
                     if ty != $uniform_ty {
                         return Err(LayoutMismatchError::TypeMismatch {
                             expected: ty,
@@ -509,13 +423,14 @@ macro_rules! impl_uniform_block_basic {
                     }
 
                     Ok(())
+
                 } else {
                     Err(LayoutMismatchError::LayoutMismatch {
                         expected: layout.clone(),
                         obtained: BlockLayout::BasicType {
                             ty: $uniform_ty,
                             offset_in_buffer: base_offset,
-                        },
+                        }
                     })
                 }
             }
@@ -528,7 +443,7 @@ macro_rules! impl_uniform_block_basic {
                 }
             }
         }
-    };
+    );
 }
 
 impl AsUniformValue for i8 {
diff --git a/src/vertex/buffer.rs b/src/vertex/buffer.rs
index f533034..e10401b 100644
--- a/src/vertex/buffer.rs
+++ b/src/vertex/buffer.rs
@@ -238,16 +238,16 @@ impl<T> VertexBuffer<T> where T: Copy {
     /// # fn example<T>(display: glium::Display<T>) where T: SurfaceTypeTrait + ResizeableSurface {
     /// use std::borrow::Cow;
     ///
-    /// let bindings = Cow::Owned(vec![(
-    ///         Cow::Borrowed("position"), 0,
+    /// const BINDINGS: glium::vertex::VertexFormat = &[(
+    ///         Cow::Borrowed("position"), 0, -1,
     ///         glium::vertex::AttributeType::F32F32,
     ///         false,
     ///     ), (
-    ///         Cow::Borrowed("color"), 2 * ::std::mem::size_of::<f32>(),
+    ///         Cow::Borrowed("color"), 2 * ::std::mem::size_of::<f32>(), -1,
     ///         glium::vertex::AttributeType::F32,
     ///         false,
     ///     ),
-    /// ]);
+    /// ];
     ///
     /// let data = vec![
     ///     1.0, -0.3, 409.0,
@@ -255,7 +255,7 @@ impl<T> VertexBuffer<T> where T: Copy {
     /// ];
     ///
     /// let vertex_buffer = unsafe {
-    ///     glium::VertexBuffer::new_raw(&display, &data, bindings, 3 * ::std::mem::size_of::<f32>())
+    ///     glium::VertexBuffer::new_raw(&display, &data, BINDINGS, 3 * ::std::mem::size_of::<f32>())
     /// };
     /// # }
     /// ```
diff --git a/src/vertex/format.rs b/src/vertex/format.rs
index e5ec034..477e93a 100644
--- a/src/vertex/format.rs
+++ b/src/vertex/format.rs
@@ -407,7 +407,8 @@ impl AttributeType {
 ///
 /// The first element is the name of the binding, the second element
 /// is the offset from the start of each vertex to this element, the
-/// third element is the type and the fourth element indicates whether
+/// third element is the layout location specified in the shader, the
+/// fourth element is the type and the fifth element indicates whether
 /// or not the element should use fixed-point normalization when
 /// binding in a VAO.
 pub type VertexFormat = &'static [(Cow<'static, str>, usize, i32, AttributeType, bool)];
diff --git a/tests/support/mod.rs b/tests/support/mod.rs
index 21ff5e3..a2a0b99 100644
--- a/tests/support/mod.rs
+++ b/tests/support/mod.rs
@@ -5,7 +5,7 @@ Test supports module.
 
 #![allow(dead_code)]
 
-use glium::{self, Display};
+use glium::Display;
 use glium::backend::Facade;
 use glium::index::PrimitiveType;
 
